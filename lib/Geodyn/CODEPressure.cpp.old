//============================================================================
//
//  This file is part of GPSTk, the GPS Toolkit.
//
//  The GPSTk is free software; you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published
//  by the Free Software Foundation; either version 3.0 of the License, or
//  any later version.
//
//  The GPSTk is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with GPSTk; if not, write to the Free Software Foundation,
//  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
//
//  Copyright 2004, The University of Texas at Austin
//  Kaifa Kuang - Wuhan University . 2015
//
//============================================================================


/**
 * @file CODEPressure.cpp
 * Class to do CODE Pressure calculation.
 */

#include "CODEPressure.hpp"
#include "GNSSconstants.hpp"

using namespace std;

namespace gpstk
{

      /** Compute acceleration (and related partial derivatives) of CODE
       *  Pressure.
       * @param utc     time in UTC
       * @param rb      earth body
       * @param sc      spacecraft
       */
   void CODEPressure::doCompute(CommonTime utc, EarthBody& rb, Spacecraft& sc)
   {
      // get satellite block type
      const string type = sc.getBlockType();

      // get satellite mass, unit: kg
      const double mass = sc.getMass();

      // get srp coefficients
      double D0(0.0), Dc(0.0), Ds(0.0);
      double Y0(0.0), Yc(0.0), Ys(0.0);
      double B0(0.0), Bc(0.0), Bs(0.0);

      if(9 == srpCoeff.size())
      {
         D0 = srpCoeff(0); Dc = srpCoeff(1); Ds = srpCoeff(2);
         Y0 = srpCoeff(3); Yc = srpCoeff(4); Ys = srpCoeff(5);
         B0 = srpCoeff(6); Bc = srpCoeff(7); Bs = srpCoeff(8);

         da_dSRP.resize(3,9,0.0);
      }
      else if(5 == srpCoeff.size())
      {
         D0 = srpCoeff(0);
         Y0 = srpCoeff(1);
         B0 = srpCoeff(2); Bc = srpCoeff(3); Bs = srpCoeff(4);

         da_dSRP.resize(3,5,0.0);
      }

      // TT
      double tt = JulianDate(pRefSys->UTC2TT(utc)).jd;

      // sun position and velocity in ICRS, unit: km, km/day
      double rv_sun[6] = {0.0};
      pSolSys->computeState(tt,
                            SolarSystem::Sun,
                            SolarSystem::Earth,
                            rv_sun);

      // moon position and velocity in ICRS, unit: km, km/day
      double rv_moon[6] = {0.0};
      pSolSys->computeState(tt,
                            SolarSystem::Moon,
                            SolarSystem::Earth,
                            rv_moon);

      // sun position in ICRS, unit: m
      Vector<double> r_sun(3,0.0);
      r_sun(0) = rv_sun[0];
      r_sun(1) = rv_sun[1];
      r_sun(2) = rv_sun[2];
      r_sun *= 1000.0;

      // moon position in ICRS, unit: m
      Vector<double> r_moon(3,0.0);
      r_moon(0) = rv_moon[0];
      r_moon(1) = rv_moon[1];
      r_moon(2) = rv_moon[2];
      r_moon *= 1000.0;


      // satellite position in ICRS, unit: m
      Vector<double> r_sat(3,0.0);
      r_sat = sc.getPosition();

      // satellite velocity in ICRS, unit: m/s
      Vector<double> v_sat(3,0.0);
      v_sat = sc.getVelocity();

      // satellite position wrt sun in ICRS, unit: m
      Vector<double> r_sunsat(3,0.0);
      r_sunsat = r_sat - r_sun;


      Vector<double> r_sat_unit = normalize(r_sat);
      Vector<double> s_unit = normalize(r_sunsat);

      double distfct = AU*AU/(norm(r_sunsat)*norm(r_sunsat));

      Vector<double> d_unit = -s_unit;

      Vector<double> nop_unit = cross(r_sat, v_sat);
      nop_unit = normalize(nop_unit);

      Vector<double> r_sun_unit = normalize(r_sun);

      Vector<double> z_inertial(3,0.0);
      z_inertial(2) = 1.0;

      Vector<double> node_unit = cross(z_inertial,nop_unit);
      node_unit = normalize(node_unit);

      double fx = dot(node_unit,r_sat_unit);

      Vector<double> tmp_unit = cross(node_unit,r_sat_unit);

      double fz = dot(tmp_unit,nop_unit);

      double u = std::atan2(fz,fx);

      double lambda = getShadowFunction(r_sat,r_sun,r_moon,SM_CONICAL);

      Vector<double> y_unit;

      if((type=="IIR" || type=="IIR-A" || type=="IIR-B" || type=="IIR-M")
        && lambda != 1.0)
      {
          y_unit = cross(-r_sat_unit,v_sat);
      }
      else
      {
          y_unit = cross(r_sat_unit,s_unit);
      }

      y_unit = normalize(y_unit);

      Vector<double> b_unit = cross(y_unit,s_unit);

      b_unit = normalize(b_unit);

      double lambda1 = lambda;
      if(lambda < 0.999) lambda1 = 0.0;

      double d0_const = 1e-6;

      tmp_unit(0) = D0 + (Dc*std::cos(u) + Ds*std::sin(u))*lambda1;
      tmp_unit(1) = Y0 + (Yc*std::cos(u) + Ys*std::sin(u))*lambda1;
      tmp_unit(2) = B0 + (Bc*std::cos(u) + Bs*std::sin(u))*lambda1;

      Vector<double> f = lambda*(tmp_unit(0)*d_unit
                               + tmp_unit(1)*y_unit
                               + tmp_unit(2)*b_unit);

      a = d0_const * f * distfct;

      /// Partials of acceleration wrt satellite position, velocity and SRP
      /// parameters

      // first, get the partials of acceleration wrt satellite position vector
      da_dr.resize(3,3,0.0);

      // then, get the partials of acceleration wrt satellite velocity vector
      da_dv.resize(3,3,0.0);
/*
      // last, get the partials of acceleration wrt scale factors of CODE SRP model
      for(int i=0; i<3; ++i)
      {
         if(9 == srpCoeff.size())
         {
            da_dSRP(i,0) = lambda * ssvec(i) * d0 * distfct;   // da / dD0
            da_dSRP(i,1) = cosu * ssvec(i) * d0 * distfct;     // da / dDc
            da_dSRP(i,2) = sinu * ssvec(i) * d0 * distfct;     // da / dDs
            da_dSRP(i,3) = yvec(i) * d0 * distfct ;            // da / dY0
            da_dSRP(i,4) = cosu * yvec(i) * d0 * distfct;      // da / dYc
            da_dSRP(i,5) = sinu * yvec(i) * d0 * distfct;      // da / dYs
            da_dSRP(i,6) = bvec(i) * d0 * distfct ;            // da / dB0
            da_dSRP(i,7) = cosu * bvec(i) * d0 * distfct;      // da / dBc
            da_dSRP(i,8) = sinu * bvec(i) * d0 * distfct;      // da / dBs
         }
         else if(5 == srpCoeff.size())
         {
            da_dSRP(i,0) = lambda * ssvec(i) * d0 * distfct;   // da / dD0
            da_dSRP(i,1) = yvec(i) * d0 * distfct ;            // da / dY0
            da_dSRP(i,2) = bvec(i) * d0 * distfct ;            // da / dB0
            da_dSRP(i,3) = cosu * bvec(i) * d0 * distfct;      // da / dBc
            da_dSRP(i,4) = sinu * bvec(i) * d0 * distfct;      // da / dBs
         }
      }
*/
   }  // End of method 'CODEPressure::doCompute()'

}  // End of namespace 'gpstk'
