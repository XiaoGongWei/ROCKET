#pragma ident "$Id: SolverPPPWL.cpp 2645 2011-06-08 03:23:24Z shjzhang $"

/**
 * @file SolverPPPWL.cpp
 * Class to fix the widelane ambiguities.
 */

//============================================================================
//
//  This file is part of GPSTk, the GPS Toolkit.
//
//  The GPSTk is free software; you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published
//  by the Free Software Foundation; either version 2.1 of the License, or
//  any later version.
//
//  The GPSTk is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with GPSTk; if not, write to the Free Software Foundation,
//  Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Shoujian Zhang - Wuhan University. 2012
//
//============================================================================
//
//  History:
//
//  (1) define the eqution apparently
//  (2) create a new class to select the ambiguity datum for single receiver
//  (3) Insert the widelane ambiguity into gnssRinex Data .
//  (4) Change the satSet to only include current satellites.
//
//  <=  satSet.insert(currSatSet.begin(), currSatSet.end());
//  =>  satSet = currSatSet;
//
//      2012.11.05
//
//============================================================================


#include "SolverPPPWL.hpp"
#include "ARLambda.hpp"
#include "ARMLambda.hpp"
#include "MatrixFunctors.hpp"

namespace gpstk
{

      // Index initially assigned to this class
   int SolverPPPWL::classIndex = 9300000;


      // Returns an index identifying this object.
   int SolverPPPWL::getIndex() const
   { return index; }


      // Returns a string identifying this object.
   std::string SolverPPPWL::getClassName() const
   { return "SolverPPPWL"; }


      /* Common constructor.
       */
   SolverPPPWL::SolverPPPWL()
      : firstTime(true)
   {

         // Set the equation system structure
      setEqu();

         // Set the class index
      setIndex();

         // Call initializing method
      Init();

   }  // End of 'SolverPPPWL::SolverPPPWL()'


      /* Sets if a NEU system will be used.
       *
       */
   SolverPPPWL& SolverPPPWL::setEqu()
   {
      // NOTES
      //
      // According to the Melbourne-Wubbena combination.
      //
      // MW = b_r - b^s - lambda_WL * N_wl + eps;
      //
      // if the single-difference MW is formed, then
      //
      // Diff_MW = -b^s(isat) - (-b^s(isat_datum)) - lambda_WL * N_wl(diff)
      //
      // and the parameters to be estimated are only the widelane 
      // ambiguities.
      //

         // Now, we build the basic equation definition
      defaultEqDef.header = TypeID::prefitMWubbena;

         // Firstly, clear the 'diffTypes'
      diffTypes.clear();

         // Define the types to be differenced
         // Warning: be ware of the order of the type in diffTypes.
      diffTypes.insert(TypeID::prefitMWubbena);
      diffTypes.insert(TypeID::weight);

      return (*this);

   }  // End of method 'SolverPPPWL::setEqu()'



      // Initializing method.
   void SolverPPPWL::Init(void)
   {

         // Pointer to stochastic model for phase biases
      pAmbiguityStoModel = &ambiguityModel;

         // Set default factor that multiplies phase weights
         // If code sigma is 1 m, the Pw sigma is 0.2500 m, the ratio is 4:1
      weightFactor = 4;       // 2^2

   }  // End of method 'SolverPPPWL::Init()'


      /* Returns a reference to a gnnsSatTypeValue object after
       * solving the previously defined equation system.
       *
       * @param gData    Data object holding the data.
       */
   gnssSatTypeValue& SolverPPPWL::Process(gnssSatTypeValue& gData)
      throw(ProcessingException,SVNumException)
   {

      try
      {

            // Build a gnssRinex object and fill it with data
         gnssRinex g1;
         g1.header = gData.header;
         g1.body = gData.body;

            // Call the Process() method with the appropriate input object
         Process(g1);

            // Update the original gnssSatTypeValue object with the results
         gData.body = g1.body;

         return gData;

      }
      catch(SVNumException& s)
      {
            // Rethrow the SVNumException
         GPSTK_RETHROW(s);

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPWL::Process()'


      /* Returns a reference to a gnnsRinex object after solving
       * the previously defined equation system.
       *
       * @param gData     Data object holding the data.
       */
   gnssRinex& SolverPPPWL::Process(gnssRinex& gData)
      throw(ProcessingException,SVNumException)
   {

      try
      {

            // Prepare everything before computing
         preCompute( gData);


            // Call the Compute() method with the defined equation model.
         Compute( gData );


            // Store data after computing
         postCompute( gData);


            // return
         return gData;

      }
      catch(SVNumException& s)
      {
            // Rethrow the SVNumException
         GPSTK_RETHROW(s);

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPWL::Process()'


      /* Code to be executed before 'Compute()' method.
       *
       * @param gData    Data object holding the data.
       */
   gnssRinex& SolverPPPWL::preCompute( gnssRinex& gData )
      throw(ProcessingException, SVNumException)
   {

      try
      {
            /**
             * Please note that there are two different sets being defined:
             *
             * - "currSatSet" stores satellites currently in view, and it is
             *   related with the number of measurements.
             *
             * - "satSet" stores satellites being processed; this set is
             *   related with the number of unknowns.
             *
             */

            // Get a set with all satellites present in this GDS
         currSatSet = gData.body.getSatID();

            // Get the number of satellites currently visible
         numCurrentSV = gData.numSats();

         cout << "numCurrentSV" << numCurrentSV << endl;

            // Check current SV number
         if(numCurrentSV < 4 )
         {
               // If epoch must be decimated, we issue an Exception
            SVNumException e("Satellite number is less than 2");
            
               // Throw exception
            GPSTK_THROW(e);
         }

            // Update set with satellites being processed so far
            // Warning: because the kalmanData in 'postCompute'
            //          are not cleared, so here you should insert 'currSatSet'
            //          into 'satSet', which will reset the values in the
            //          kalmanData, when the satellite is not visible again
         satSet.insert( currSatSet.begin(), currSatSet.end() );

            // Get the number of satellites to be processed
         int numSV( satSet.size() );

            // Total number of unknowns equals with 
            // the widelane ambiguities' number
         numUnknowns = numSV;

            /**
             * Now, Let's get the phiMatrix and qMatrix
             */

            // State Transition Matrix (PhiMatrix)
         phiMatrix.resize(numUnknowns, numUnknowns, 0.0);

            // Noise covariance matrix (QMatrix)
         qMatrix.resize(numUnknowns, numUnknowns, 0.0);


            // Now, let's fill the Phi and Q matrices
         SatID  dummySat;

            // only the phase biases
         int count1(0);      
         for( SatIDSet::const_iterator itSat = satSet.begin();
              itSat != satSet.end();
              ++itSat )
         {
               // Prepare stochastic model
            pAmbiguityStoModel->Prepare( *itSat,
                                         gData );

               // Get values into phi and q matrices
            phiMatrix(count1,count1) = pAmbiguityStoModel->getPhi();
            qMatrix(count1,count1)   = pAmbiguityStoModel->getQ();

            ++count1;
         }

            // Feed the filter with the correct state and covariance matrix
         if(firstTime)
         {

            Vector<double> initialState(numUnknowns, 0.0);
            Matrix<double> initialErrorCovariance( numUnknowns,
                                                   numUnknowns,
                                                   0.0 );

               // Fill the initialErrorCovariance matrix

               // only the phase biases
            for( int i=0; i<numUnknowns; i++ )
            {
               initialErrorCovariance(i,i) = 4.0e14;     // (20000 km)**2
            }

               // Reset Kalman filter state and covariance matrix
            xhat = initialState; 
            P    = initialErrorCovariance;

               // No longer first time
            firstTime = false;

         }
         else
         {

               // Adapt the size to the current number of unknowns
            Vector<double> currentState(numUnknowns, 0.0);
            Matrix<double> currentErrorCov(numUnknowns, numUnknowns, 0.0);


               // Fill in the rest of state vector and covariance matrix
               // These are values that depend on satellites being processed
            int c1(0);
            for( SatIDSet::const_iterator itSat = satSet.begin();
                 itSat != satSet.end();
                 ++itSat )
            {

                  // Put ambiguities into state vector
               currentState(c1) = KalmanData[*itSat].ambiguity;

                  // Put ambiguities covariance values into covariance matrix
                  // This fills the lower right quadrant of covariance matrix
               int c2(0);
               SatIDSet::const_iterator itSat2;
               for( itSat2 = satSet.begin(); itSat2 != satSet.end(); ++itSat2 )
               {

                  currentErrorCov(c1,c2) = KalmanData[*itSat].aCovMap[*itSat2];
                  currentErrorCov(c2,c1) = KalmanData[*itSat].aCovMap[*itSat2];

                  ++c2;
               }

               ++c1;
            }

               // Reset Kalman filter to current state and covariance matrix
            xhat = currentState;
            P    = currentErrorCov;

         }  // End of 'if(firstTime)'

      }
      catch(SVNumException& s)
      {
            // Rethrow the SVNumException
         GPSTK_RETHROW(s);

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

      return gData;

   }  // End of method 'SolverPPPWL::preCompute()'



      // Compute the solution of the given equations set.
      //
      // @param gData    Data object holding the data.
      //
      // \warning A typical kalman filter will be devided into 
      // two different phase, the prediction and the correction.
      // for some special application, for example, the 'integer'
      // satellite and receiver clock/bias estimation, the ambiguity
      // constraints are generated using the 'predicted' ambiguity 
      // values and its variances. 
      //
   gnssRinex& SolverPPPWL::Compute( gnssRinex& gData )
      throw(InvalidSolver)
   {

         // Call the TimeUpdate() of the kalman filter, which will predict the 
         // state vector and their covariance matrix
      TimeUpdate( phiMatrix, qMatrix );


         // In order to isolate the receiver phase biases and fix all the ambiguities
         // to integers, you should choose one satellite's ambiguity as datum, and 
         // fix it to the nearest integer.
      AmbiguityConstr( gData );


         // Call the MeasUpdate() of the kalman filter, which will update the 
         // state vector and their covariance using new measurements.
      MeasUpdate( measVector, hMatrix, rMatrix );


         // Now, Let's fix all the potential ambiguities after introducting the 
         // independent ambiguities.
      AmbiguityFixing( gData );


         // Return  
      return gData;

   }  // End of method 'SolverPPPWL::Compute()'


      // Predict the state vector and covariance matrix
      //
      // @param gData    Data object holding the data.
      //
   int SolverPPPWL::TimeUpdate( const Matrix<double>& phiMatrix,
                                const Matrix<double>& processNoiseCovariance )
      throw(InvalidSolver)
   {

         // Check whether the phiMatrix is square
      if (!(phiMatrix.isSquare()))
      {
         InvalidSolver e("phiMatrix is not square");
         GPSTK_THROW(e);
      }


      int stateSize(xhat.size());
      if(!(stateSize==numUnknowns))
      {
         InvalidSolver e("TimeUpdate(): Size of a posteriori state estimation vector \
do not match the number of unknowns");
         GPSTK_THROW(e);
      }


      int phiRow = static_cast<int>(phiMatrix.rows());
      if (!(phiRow==numUnknowns))
      {
         InvalidSolver e("Number of unknowns does not match dimension \
of phiMatrix");
         GPSTK_THROW(e);
      }

      if (!(qMatrix.isSquare()))
      {
         InvalidSolver e("qMatrix is not square");
         GPSTK_THROW(e);
      }

      int qRow = static_cast<int>(qMatrix.rows());
      if (!(qRow==numUnknowns))
      {
         InvalidSolver e("Number of unknowns does not match dimension \
of qMatrix");
         GPSTK_THROW(e);
      }

      try
      {
            // Compute the a priori state vector
         xhatminus = phiMatrix*xhat;

         Matrix<double> phiT(transpose(phiMatrix));

            // Compute the a priori estimate error covariance matrix
         Pminus = phiMatrix*P*phiT + processNoiseCovariance;

      }
      catch(...)
      {
         InvalidSolver e("TimeUpdate(): Unable to predict next state.");
         GPSTK_THROW(e);
         return -1;
      }
        
      return 0;

   }  // End of method 'SolverPPPWL::TimeUpdate()'



      /** Returns a reference to a gnnsRinex object after fixing
       * the ambiguities.
       *
       * @param gData    Data object holding the data.
       */
   gnssRinex& SolverPPPWL::AmbiguityConstr( gnssRinex& gData )
      throw(ProcessingException)
   {
      try
      {

            // Ambiguity map
         std::map<SatID, double> ambMap;

            // Ambiguity covariance map
         std::map<SatID, std::map<SatID, double> > ambCovMap;

            // Get predicted ambiguity estimation and their covariance values
         int c1(0);
         for( SatIDSet::const_iterator itSat = satSet.begin();
              itSat != satSet.end();
              ++itSat )
         {
            ambMap[ (*itSat) ] = xhatminus(c1);

               // Put ambiguities covariance values into 'ambCovMap'
            int c2(0);
            SatIDSet::const_iterator itSat2;
            for( itSat2 = satSet.begin(); itSat2 != satSet.end(); ++itSat2 )
            {
               ambCovMap[ (*itSat) ][ (*itSat2) ] = Pminus(c1,c2);
               ++c2;
            }

               // Indent increment
            ++c1;

         }  // End of 'for( itSat = satSet.begin(); ...'

            // Clear the map
         ambDatumMap.clear();

            // Set the ambiguity value and covariance map
         ambiguityDatum.Reset( ambMap, ambCovMap );

            // Now, Let's fix one satellite's ambiguity as datum
         ambiguityDatum.Prepare( gData );

            // Ambiguity datum SatID
         ambDatumMap = ambiguityDatum.getAmbFixedMap();

            //
            // Compute the single difference observations between satellites.
            //

            // Map iterator
         std::map<SatID, double>::iterator itmap = ambDatumMap.begin();
         
            // Get the reference SatID
         datumSat = ( (*itmap).first );

            // We will use reference satellite data as reference data
         satTypeValueMap datumData(gData.body.extractSatID(datumSat));

            // Satellite number with single difference observables
         int numObsSV( numCurrentSV - 1 );

            // Get the number of the types to be differenced
         int numType(diffTypes.size());

            // Resize the diffData
         diffData.resize(numObsSV, numType, 0.0);

            // SatIDSet to be rejected
         SatIDSet satRejectedSet;

            // Loop through all the satellites in station data set
         int row(0);
         for (satTypeValueMap::iterator it = gData.body.begin(); 
              it != gData.body.end(); 
              ++it)
         {

               // 'datumSat' is the reference one
            if( (*it).first != datumSat )
            {
                  // Compute the difference for all types in 'diffTypes' set
               int col(0);
               for(TypeIDSet::const_iterator itType = diffTypes.begin(); 
                   itType != diffTypes.end(); 
                   ++itType)
               {

                  double value1(0.0);
                  double value2(0.0);

                  try
                  {
                        // Let's try to compute the difference
                     value1 = gData.body((*it).first)(*itType);
                     value2 = datumData(datumSat)(*itType);

                     double diffValue(0.0);

                     if( (*itType) == TypeID::weight )
                     {
                        diffValue = 1.0/( 1.0/value1 + 1.0/value2 );
                     }
                     else
                     {
                        diffValue = value1 - value2;
                     }

                        // Store the difference into vector
                     diffData(row,col) = diffValue;

                  }
                  catch(...)
                  {
                        // If some value is missing, then schedule this satellite
                        // for removal
                     satRejectedSet.insert( (*it).first );

                     continue;

                  }

                     // Type number increment
                  ++col;

               }  // End of 'for(itType = diffTypes.begin(); ...'

                  // Satellite number increment
               ++row;

            }  // End of 'if( (*it).first != datumSat )'

         }  // End of 'for (it = gData.begin(); it != gData.end(); ++it)'


            //
            // Now, Define new single difference observation equation, 
            // including measVector, hMatrix and wMatrix
            //

            // Number of measurements equals with the SD observation number.
         numMeas = numObsSV;

            // Measurement vector
         measVector.resize(numMeas, 0.0);

            // Fill the measment difference value
         for( int i=0; i<numObsSV; i++ )
         {
            measVector( i ) = diffData(i,0);
         }

            // Now, fill the geometry matrix

            // Generate the corresponding geometry/design matrix
         hMatrix.resize(numMeas, numUnknowns, 0.0);


            // Now, find the position of datumSat in 'satSet'
         int jref(0);
         SatIDSet::const_iterator itSat2( satSet.begin() );
         while( (*itSat2) != datumSat )
         {
            ++jref;
            ++itSat2;
         }

            // Now, fill the coefficients related to phase biases
            // We must be careful because not all processed satellites
            // are currently visible
         int count1(0);
         for( SatIDSet::const_iterator itSat = currSatSet.begin();
              itSat != currSatSet.end();
              ++itSat )
         {
               // Only set the "active" satellite
            if( (*itSat) != datumSat )
            {
                  // Find in which position of 'satSet' is the current '(*itSat)'
                  // Please note that 'currSatSet' is a subset of 'satSet'
               int j(0);
               SatIDSet::const_iterator itSat2( satSet.begin() );
               while( (*itSat2) != (*itSat) )
               {
                  ++j;
                  ++itSat2;
               }

                  // Put coefficient in the right place
               hMatrix( count1 , j    ) = -0.861918400;

                  // Put coefficient of the 'datumSat'  
               hMatrix( count1 , jref ) = +0.861918400;

                  // Increment
               ++count1;
            }

         }  // End of 'for( itSat = satSet.begin(); ... )'

            // Now, get the weight matrix

            // Weights matrix
         rMatrix.resize(numMeas, numMeas, 0.0);

            // Generate the appropriate weights matrix
            // Try to extract weights from GDS
         satTypeValueMap dummy(gData.body.extractTypeID(TypeID::weight));

            // Check if weights match
            // here the dummy size is only used to check whether we have
            // weight values in 'gData'
         if ( dummy.numSats() == numCurrentSV )
         {
               // Warning: numCurrentSV - numObsSV = 1  !!!!!!!
            for( int i=0; i<numObsSV; i++ )
            {
                  // The order of TypeID::weight in 'diffData' is 2
               rMatrix( i, i ) = diffData(i, 1) * weightFactor;
            }

         }
         else
         {
               // If weights don't match, assign generic weights
            for( int i=0; i<numObsSV; i++ )
            {
               rMatrix( i, i ) = 1.0 * weightFactor;
            }  

         }  // End of 'if ( dummy.numSats() == numCurrentSV )'


            // Now, extend the equation measurements, design matrix
            // and weight matrix with the datum satellite' equation

            // Throw exception
         if( ambDatumMap.size() != 1 )
         {
               // Throw an exception if something unexpected happens
            ProcessingException e("The ambiguity constraint equation number is 0.");

               // Throw the exception
            GPSTK_THROW(e);

         }  // End of 'If(...)'

         Vector<double> measVectorDatum(1,0.0);
         Matrix<double> hMatrixDatum(1,numUnknowns,0.0);
         Matrix<double> rMatrixDatum(1, 1,0.0);

            // Now, get datum satellite's ambiguity constraint equation
            
            // Prefit equals the fixed ambiguity value 
         measVectorDatum( 0 ) = ambDatumMap[ datumSat ];

            // Coefficient of ambiguity is set to 1.0
         hMatrixDatum( 0, jref) = 1.0;

            // The weight is set to a large value
         rMatrixDatum( 0, 0) = 1.0E+8;

            /**
             * Now, Let's combine the measurement equation and constraint 
             * equation together 
             */

            // The observation equation number is enlarged
         int numEqu( numMeas+1 );

            // New observation prefit/geometry/weight matrix
         Vector<double> tempPrefit(numEqu, 0.0);
         Matrix<double> tempGeometry(numEqu, numUnknowns, 0.0);
         Matrix<double> tempWeight(numEqu, numEqu, 0.0);

            // Now, Let's store the measVector/hMatrix/rMatrix
         for(int i=0; i<numMeas; i++)
         {
               // Prefit
            tempPrefit(i) = measVector(i); 

               // Geometry
            for(int j=0; j<numUnknowns; j++) 
            { 
               tempGeometry(i,j) = hMatrix(i,j); 
            }

               // Weight
            tempWeight(i,i) = rMatrix(i,i); 
         }

            // Now, add the datum satellite ambiguity constraint equation to 
            // the last position of the 'tempPrefit/tempGeometry/tempWeight'
            
            // Prefit
         tempPrefit(numMeas) = measVectorDatum(0); 

            // Geometry
         for(int j=0; j<numUnknowns; j++)
         {
            tempGeometry(numMeas,j) = hMatrixDatum(0,j); 
         }  

            // Weight
         tempWeight(numMeas,numMeas) = rMatrixDatum(0,0); 


            // Resize the measVector/hMatrix/rMatrix
         measVector.resize(numEqu,  0.0);
         hMatrix.resize(numEqu, numUnknowns, 0.0);
         rMatrix.resize(numEqu, numEqu, 0.0);

            // New Measurement vector update
         measVector = tempPrefit ;
         hMatrix = tempGeometry ;
         rMatrix = tempWeight ;

            // Return 
         return gData;

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPWL::AmbiguityConstr()'
    



      // Correct the state vector and covariance matrix
      //
      // @param gData    Data object holding the data.
      //
   int SolverPPPWL::MeasUpdate( const Vector<double>& prefitResiduals,
                                const Matrix<double>& designMatrix,
                                const Matrix<double>& weightMatrix )
      throw(InvalidSolver)
   {

         // By default, results are invalid
      valid = false;

      if (!(weightMatrix.isSquare()))
      {
         InvalidSolver e("MeasUpdate(): Weight matrix is not square");
         GPSTK_THROW(e);
      }


      int wRow = static_cast<int>(weightMatrix.rows());
      int pRow = static_cast<int>(prefitResiduals.size());
      if (!(wRow==pRow))
      {
         InvalidSolver e("MeasUpdate(): prefitResiduals size does not match dimension of \
weightMatrix");
         GPSTK_THROW(e);
      }


      int gRow = static_cast<int>(designMatrix.rows());
      if (!(gRow==pRow))
      {
         InvalidSolver e("MeasUpdate(): prefitResiduals size does not match \
dimension of designMatrix");
         GPSTK_THROW(e);
      }


      int gCol = static_cast<int>(designMatrix.cols());
      int aprioriStateRow = static_cast<int>(xhatminus.size());
      if (!(gCol==aprioriStateRow))
      {
         InvalidSolver e("MeasUpdate(): designMatrix size and a priori state \
estimation vector do not match.");
         GPSTK_THROW(e);
      }


      int pMCol = static_cast<int>(Pminus.cols());
      if ( pMCol != aprioriStateRow )
      {
         InvalidSolver e("MeasUpdate(): Sizes of a priori error covariance \
matrix and a priori state estimation vector do not match.");
         GPSTK_THROW(e);
      }


         // After checking sizes, let's do the real correction work
      Matrix<double> invPMinus;
      Matrix<double> designMatrixT( transpose(designMatrix) );

      try
      {

         invPMinus = inverseChol(Pminus);

      }
      catch(...)
      {
         InvalidSolver e("MeasUpdate(): Unable to compute invPMinus matrix.");
         GPSTK_THROW(e);
         return -1;
      }

      try
      {

         Matrix<double> invTemp( designMatrixT * weightMatrix * designMatrix +
                                 invPMinus );

            // Compute the a posteriori error covariance matrix
         P = inverseChol( invTemp );

      }
      catch(...)
      {
         InvalidSolver e("MeasUpdate(): Unable to compute P matrix.");
         GPSTK_THROW(e);
         return -1;
      }

      try
      {

            // Compute the a posteriori state estimation
         xhat = P * ( (designMatrixT * weightMatrix * prefitResiduals) + 
                      (invPMinus * xhatminus) );

      }
      catch(Exception e)
      {
         InvalidSolver eis("MeasUpdate(): Unable to compute xhat.");
         GPSTK_THROW(eis);
         return -1;
      }


      solution = xhat;
      covMatrix = P;

         // Compute the postfit residuals Vector
      postfitResiduals = ( prefitResiduals - (designMatrix * solution) ) ;

         // If everything is fine so far, then the results should be valid
      valid = true;

      return 0;

   }  // End of method 'SolverPPPWL::MeasUpdate()'


      /** Returns a reference to a gnnsRinex object after fixing
       * the ambiguities.
       *
       * @param gData    Data object holding the data.
       */
   gnssRinex& SolverPPPWL::AmbiguityFixing( gnssRinex& gData )
      throw(ProcessingException)
   {

      try
      {

            // Now, define the temporary solution and covMatrix
         Vector<double> newState ; 
         Matrix<double> newCovariance ;

         newState = solution ;
         newCovariance = covMatrix ;

            // Temp Variables
         double sigma, value, variance, decision, ambWLFixed;

            // Cutting decision for ambiguity fixing 
         double cutDec(1000.0);

            // Vector to indicate the state of the unknowns: 
            // 1 means free and 0 means fixed.
         Vector<double> ambWLFlag(numUnknowns, 0.0);

            // Ambiguity fixing method
         ARRound ambRes(1000,0.3,0.3);

            // Still have ambiguity to be fixed?
         bool done(false);

            // Loop to fix a ambiguity
         while( !done )
         {
               // Indicator variable
            int index(-1);
            double maxDec(-100.0);

               // Only fix the ambiguity unks 
            for( int i=0; i<numUnknowns; i++)
            {
                  // If still free 
               if( ambWLFlag(i) == 0.0 )
               {
                     // Ambiguity value
                  value = newState(i);

                     // Variance 
                  variance = newCovariance(i,i);

                     // Sigma 
                  sigma = std::sqrt( variance );

                     // Ambiguity fixing decision
                  decision = ambRes.getDecision(value, sigma);

                     // Look for the largest fixing decision
                  if( decision > maxDec )
                  {
                     index = i;
                     maxDec = decision;
                  }

               }  // End of 'if( ambWLFlag(i) == 0.0 ) '

            }   // End of 'for(int i=0; ... )'

               // If found 
            if(index != -1)
            {
                  // If can be fixed
               if( maxDec > cutDec )
               {
                     // Ambiguity value
                  value = newState(index);

                     // Variance 
                  variance = newCovariance(index,index);

                     // Get the fixed ambiguity value
                  ambWLFixed = ambRes.resolve(value, variance);

                     // Update the solution and covarinace  
                  AmbiguityUpdate(newState, newCovariance, ambWLFlag, index, ambWLFixed );

                     // Not free at all
                  ambWLFlag(index) = 1.0;

                     // Store the fixed ambiguity value into 'state'
                  newState(index) = ambWLFixed;

               }
               else
               {
                    // If ambiguity can't be fixed
                  done = true;
               } 

            }
            else
            {
                 // if no ambiguity is found
               done = true;
            }
                
         }  // End of 'while(done)'


            // Get the number of satellites currently visible
         int numCurrentSV( gData.numSats() );

            // New vector to store the flags
         Vector<double> currAmb(numCurrentSV,0.0);
         Vector<double> currAmbFlag(numCurrentSV,0.0);

            // Number of fixed widelane ambiguities
         double numWLFixed(0);

            // Now, only take out current ambiguity and their state 
         int count1(0);
         for( SatIDSet::const_iterator itSat = currSatSet.begin();
              itSat != currSatSet.end();
              ++itSat )
         {
            int jcol(0);
            SatIDSet::const_iterator itSat2( satSet.begin() );
            while( (*itSat2) != (*itSat) )
            {
               ++jcol;
               ++itSat2;
            }

               // The ambiguity value
            currAmb(count1) = newState( jcol );

               // The ambiguity fixed flag
            currAmbFlag(count1) = ambWLFlag( jcol );

               // If the widelane satellite is fixed
            if( currAmbFlag(count1) )
            {
               numWLFixed++;
            }

               // Index increment
            ++count1;

         }


         cout << "BWL" << endl;
         cout <<  currAmb  << endl;

         cout << "BWLFlag" << endl;
         cout <<  currAmbFlag  << endl;

            // Now, we have to add the new values to the data structure
         gData.insertTypeIDVector(TypeID::BWL,     currAmb);
         gData.insertTypeIDVector(TypeID::BWLFlag, currAmbFlag);

         ///////////// ///////////// ///////////// /////////////
         //
         // WARNING:
         // we don't store the updated 'newState/newCovariance' 
         // to 'solution/covariance', because the covariance
         // value of the fixed ambiguity is very small, which 
         // will cause the inversion error of Pminus in 'MeasUpdate'
         //
         ///////////// ///////////// ///////////// /////////////

            // Return 
         return gData;

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPWL::AmbiguityFixing()'


      /** Update the free unknonws' solution and covariance after
       *  fixing the ambiguities
       */
   int SolverPPPWL::AmbiguityUpdate( Vector<double>& state,
                                     Matrix<double>& covariance,
                                     Vector<double>& fixedFlag,
                                     int& index,
                                     double& fixedValue )
      throw(ProcessingException)
   {

      try
      {
            // Variance epsilon to avoid numerical exception
         const double eps(1.0e-9);

            // Covariance related to the fixed ambiguity
         Vector<double> Qba(numUnknowns, 0.0);

            // Get the covariance
         for( int i=0; i<numUnknowns; i++)
         {
            Qba(i) = covariance(i,index);
         }

            // Qii
         double Qaa;
         Qaa = Qba(index) + eps;
         Qaa = 1.0/Qaa;

            // Free value
         double freeValue = state(index);

            // Solution udpate
         for(int i=0; i<numUnknowns; i++)
         {
            if( fixedFlag(i) == 0.0 )
            {
               state(i) = state(i) + Qba(i)*Qaa*(fixedValue - freeValue); 
            }
         }

            // Covariance update
         for(int i=0; i<numUnknowns; i++)
         {
            if( fixedFlag(i) == 0.0 )
            {
               for(int j=0; j<numUnknowns; j++)
               {
                  if( fixedFlag(j) == 0.0 )
                  {
                     covariance(i,j) = covariance(i,j) - Qba(i)*Qaa*Qba(j);
                  }
               }
            }
         }

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPWL::AmbiguityUpdate()'


      /* Code to be executed after 'Compute()' method.
       *
       * @param gData    Data object holding the data.
       */
   gnssRinex& SolverPPPWL::postCompute( gnssRinex& gData )
      throw(ProcessingException)
   {

      try
      {
            // Now, Let's seperate the unknowns to ambiguity ones and 
            // the 'core' ones
            // Store those values of current state and covariance matrix
            // that depend on satellites currently in view
         int c1(0);
         for( SatIDSet::const_iterator itSat = satSet.begin();
              itSat != satSet.end();
              ++itSat )
         {

               // Store ambiguities
            KalmanData[*itSat].ambiguity = solution(c1);

               // Store ambiguities covariance values
            int c2(0);
            SatIDSet::const_iterator itSat2;
            for( itSat2 = satSet.begin(); itSat2 != satSet.end(); ++itSat2 )
            {

               KalmanData[*itSat].aCovMap[*itSat2] = covMatrix(c1,c2);

               ++c2;
            }

            ++c1;

         }  // End of 'for( itSat = satSet.begin(); ...'

            // Update set of satellites to be used in next epoch
         satSet = currSatSet;


         return gData;

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

      return gData;

   }  // End of method 'SolverPPPWL::postCompute()'


      /* Set a single coordinates stochastic model to ALL coordinates.
       *
       * @param pModel      Pointer to StochasticModel associated with
       *                    coordinates.
       *
       * @warning Do NOT use this method to set the SAME state-aware
       * stochastic model (like RandomWalkModel, for instance) to ALL
       * coordinates, because the results will certainly be erroneous. Use
       * this method only with non-state-aware stochastic models like
       * 'StochasticModel' (constant coordinates) or 'WhiteNoiseModel'.
       */
   SolverPPPWL& SolverPPPWL::setCoordinatesModel( StochasticModel* pModel )
   {

         // All coordinates will have the same model
      pCoordXStoModel = pModel;
      pCoordYStoModel = pModel;
      pCoordZStoModel = pModel;

      return (*this);

   }  // End of method 'SolverPPPWL::setCoordinatesModel()'


      /** Set the positioning mode, kinematic or static.
       */
   SolverPPPWL& SolverPPPWL::setKinematic( bool kinematicMode,
                                           double sigmaX,
                                           double sigmaY,
                                           double sigmaZ )
   {
      if(kinematicMode)
      {
         whitenoiseModelX.setSigma(sigmaX);
         whitenoiseModelY.setSigma(sigmaY);
         whitenoiseModelZ.setSigma(sigmaZ);

         setXCoordinatesModel(&whitenoiseModelX);
         setYCoordinatesModel(&whitenoiseModelY);
         setZCoordinatesModel(&whitenoiseModelZ);
      }
      else
      {
         setCoordinatesModel(&constantModel);
      }

      return (*this);

   }  // End of method 'SolverPPPWL::setKinematic()'


      /* Returns the solution associated to a given TypeID.
       *
       * @param type    TypeID of the solution we are looking for.
       */
   double SolverPPPWL::getSolution(const TypeID& type) const
      throw(InvalidRequest)
   {

         // Define iterator
      TypeIDSet::const_iterator it;

         // Check if the provided type exists in the solution. If not,
         // an InvalidSolver exception will be issued.
      it = defaultEqDef.body.find(type);
      if( it == defaultEqDef.body.end() )
      {
         InvalidRequest e("Type not found in solution vector.");
         GPSTK_THROW(e);
      }


         // Define counter
      int counter(0);

         // Define a new iterator and count where the given type is
      TypeIDSet::const_iterator it2;
      for (it2 = defaultEqDef.body.begin(); it2!= it; it2++)
      {
         ++counter;
      }

      return newSol(counter);

   }  // End of method 'SolverPPPWL::getSolution()'



      /* Returns the variance associated to a given TypeID.
       *
       * @param type    TypeID of the variance we are looking for.
       */
   double SolverPPPWL::getVariance(const TypeID& type) const
      throw(InvalidRequest)
   {

         // Define iterator
      TypeIDSet::const_iterator it;


         // Check if the provided type exists in the covariance matrix. If not,
         // an InvalidSolver exception will be issued.
      it = defaultEqDef.body.find(type);
      if( it == defaultEqDef.body.end() )
      {
         InvalidRequest e("Type not found in covariance matrix.");
         GPSTK_THROW(e);
      }


         // Define counter
      int counter(0);

         // Define a new iterator and count where the given type is
      TypeIDSet::const_iterator it2;
      for (it2 = defaultEqDef.body.begin(); it2!= it; it2++)
      {
         ++counter;
      }

      return newCov(counter,counter);

   }  // End of method 'SolverPPPWL::getVariance()'


      /** Return the CURRENT number of satellite.
       */
   int SolverPPPWL::getCurrentSatNumber() const
      throw(InvalidRequest)
   {
         // Return current fixed satellite number
      return numCurrentSV;
   }


      /** Return the CURRENT number of satellite.
       */
   int SolverPPPWL::getCurrentFixedSatNumber() const
      throw(InvalidRequest)
   {
         // Return current fixed satellite number
      return numWLFixed;
   }




}  // End of namespace gpstk
