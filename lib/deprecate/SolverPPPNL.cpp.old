#pragma ident "$Id: SolverPPPNL.cpp 2645 2012-11-05 03:23:24Z shjzhang $"

/**
 * @file SolverPPPNL.cpp
 * Class to compute the PPP Solution by fixing the ambiguities.
 */

//============================================================================
//
//  This file is part of GPSTk, the GPS Toolkit.
//
//  The GPSTk is free software; you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published
//  by the Free Software Foundation; either version 2.1 of the License, or
//  any later version.
//
//  The GPSTk is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with GPSTk; if not, write to the Free Software Foundation,
//  Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Shoujian Zhang - Wuhan University, 2012  
//
//============================================================================


#include "SolverPPPNL.hpp"
#include "MatrixFunctors.hpp"


namespace gpstk
{

      // Index initially assigned to this class
   int SolverPPPNL::classIndex = 9300000;


      // Returns an index identifying this object.
   int SolverPPPNL::getIndex() const
   { return index; }


      // Returns a string identifying this object.
   std::string SolverPPPNL::getClassName() const
   { return "SolverPPPNL"; }


      /* Common constructor.
       *
       * @param useNEU   If true, will compute dLat, dLon, dH coordinates;
       *                 if false (the default), will compute dx, dy, dz.
       */
   SolverPPPNL::SolverPPPNL(bool useNEU)
      : firstTime(true)
   {

         // Set the equation system structure
      setNEU(useNEU);

         // Set the class index
      setIndex();

         // Call initializing method
      Init();

   }  // End of 'SolverPPPNL::SolverPPPNL()'



      // Initializing method.
   void SolverPPPNL::Init(void)
   {

         // Set qdot value for default random walk stochastic model
      rwalkModel.setQprime(3e-8);

         // Pointer to default stochastic model for troposphere (random walk)
      pTropoStoModel = &rwalkModel;

         // Set default coordinates stochastic model (constant)
      setCoordinatesModel( &constantModel );

      whitenoiseModelX.setSigma(100.0);
      whitenoiseModelY.setSigma(100.0);
      whitenoiseModelZ.setSigma(100.0);

         // Pointer to default receiver clock stochastic model (white noise)
      pClockStoModel = &whitenoiseModel;

         // Pointer to stochastic model for phase biases
      pBiasStoModel  = &biasModel;

         // Set default factor that multiplies phase weights
         // If code sigma is 1 m and phase sigma is 2 cm, the ratio is 100:1
      weightFactor = 10000.0;       // 100^2


   }  // End of method 'SolverPPPNL::Init()'




      /* Returns a reference to a gnnsSatTypeValue object after
       * solving the previously defined equation system.
       *
       * @param gData    Data object holding the data.
       */
   gnssSatTypeValue& SolverPPPNL::Process(gnssSatTypeValue& gData)
      throw(ProcessingException, SVNumException)
   {

      try
      {

            // Build a gnssRinex object and fill it with data
         gnssRinex g1;
         g1.header = gData.header;
         g1.body = gData.body;

            // Call the Process() method with the appropriate input object
         Process(g1);

            // Update the original gnssSatTypeValue object with the results
         gData.body = g1.body;

         return gData;

      }
      catch(SVNumException& s)
      {
            // Rethrow the SVNumException
         GPSTK_RETHROW(s);

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPNL::Process()'


      /* Returns a reference to a gnnsRinex object after solving
       * the previously defined equation system.
       *
       * @param gData     Data object holding the data.
       */
   gnssRinex& SolverPPPNL::Process(gnssRinex& gData)
      throw(ProcessingException, SVNumException)
   {

      try
      {

            // Prepare everything before computing
         preCompute( gData);


            // Call the Compute() method with the defined equation model.
         Compute( gData );


            // Store data after computing
         postCompute( gData);


            // return
         return gData;

      }
      catch(SVNumException& s)
      {
            // Rethrow the SVNumException
         GPSTK_RETHROW(s);

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPNL::Process()'


      /* Code to be executed before 'Compute()' method.
       *
       * @param gData    Data object holding the data.
       */
   gnssRinex& SolverPPPNL::preCompute( gnssRinex& gData )
      throw(ProcessingException, SVNumException)
   {

         // Please note that there are two different sets being defined:
         //
         // - "currSatSet" stores satellites currently in view, and it is
         //   related with the number of measurements.
         //
         // - "satSet" stores satellites being processed; this set is
         //   related with the number of unknowns.
         //
         
      try
      {

         cout << static_cast<YDSTime>(gData.header.epoch).year         << "  ";    // Year           #1
         cout << static_cast<YDSTime>(gData.header.epoch).doy          << "  ";    // DayOfYear      #2
         cout << static_cast<YDSTime>(gData.header.epoch).sod   << endl;    // SecondsOfDay   #3

            // Get a set with all satellites present in this GDS
         currSatSet = gData.body.getSatID();

            // Get the number of satellites currently visible
         numCurrentSV =  gData.numSats();

         cout << "numSats:" << numCurrentSV << endl;

            // Check current SV number
         if(numCurrentSV < 4 )
         {
               // If epoch must be decimated, we issue an Exception
            SVNumException e("Satellite number is less than 4");
            
               // Throw exception
            GPSTK_THROW(e);
         }


            // Update set with satellites being processed so far
         satSet.insert( currSatSet.begin(), currSatSet.end() );

            // Get the number of satellites to be processed
         int numSV( satSet.size() );


            // Number of 'core' variables: Coordinates, RX clock, troposphere
         numVar = defaultEqDef.body.size();

            // Total number of unknowns is defined as variables + processed SVs
            // i.e. 1 trospheric delay + 3 coordinates + numSV ambiguities
         numUnknowns = numVar + numSV;


            // Now, Fill the phiMatrix and qMatrix

            // State Transition Matrix (PhiMatrix)
         phiMatrix.resize(numUnknowns, numUnknowns, 0.0);

            // Noise covariance matrix (QMatrix)
         qMatrix.resize(numUnknowns, numUnknowns, 0.0);


            // Now, let's fill the Phi and Q matrices
         SatID  dummySat;

            // First, the troposphere
         pTropoStoModel->Prepare( dummySat,
                                  gData );
         phiMatrix(0,0) = pTropoStoModel->getPhi();
         qMatrix(0,0)   = pTropoStoModel->getQ();


            // Second, the coordinates
         pCoordXStoModel->Prepare(dummySat, gData);
         phiMatrix(1,1) = pCoordXStoModel->getPhi();
         qMatrix(1,1)   = pCoordXStoModel->getQ();

         pCoordYStoModel->Prepare(dummySat, gData);
         phiMatrix(2,2) = pCoordYStoModel->getPhi();
         qMatrix(2,2)   = pCoordYStoModel->getQ();

         pCoordZStoModel->Prepare(dummySat, gData);
         phiMatrix(3,3) = pCoordZStoModel->getPhi();
         qMatrix(3,3)   = pCoordZStoModel->getQ();

         //////////////////////////////////////////////////////
         //
         //                   MOTES
         // The receiver clock is elimiated now.
         //
         //////////////////////////////////////////////////////


            // Finally, the phase biases
         int count2(numVar);     // and now, the numVar = 4;
         for( SatIDSet::const_iterator itSat = satSet.begin();
              itSat != satSet.end();
              ++itSat )
         {

               // Prepare stochastic model
            pBiasStoModel->Prepare( *itSat,
                                    gData );

               // Get values into phi and q matrices
            phiMatrix(count2,count2) = pBiasStoModel->getPhi();
            qMatrix(count2,count2)   = pBiasStoModel->getQ();

            ++count2;
         }


            // Feed the filter with the correct state and covariance matrix
         if(firstTime)
         {

            Vector<double> initialState(numUnknowns, 0.0);
            Matrix<double> initialErrorCovariance( numUnknowns,
                                                   numUnknowns,
                                                   0.0 );

               // Fill the initialErrorCovariance matrix

               // First, the zenital wet tropospheric delay
            initialErrorCovariance(0,0) = 0.25;          // (0.5 m)**2

               // Second, the coordinates
            for( int i=1; i<numVar; i++ )
            {
               initialErrorCovariance(i,i) = 1.0;       // (0.1 m)**2
            }

               // Finally, the phase biases
            for( int i=numVar; i<numUnknowns; i++ )
            {
               initialErrorCovariance(i,i) = 4.0e14;     // (20000 km)**2
            }

               // Reset Kalman filter state and covariance matrix
            xhat = initialState; 
            P    = initialErrorCovariance;

               // No longer first time
            firstTime = false;

         }
         else
         {

               // Adapt the size to the current number of unknowns
            Vector<double> currentState(numUnknowns, 0.0);
            Matrix<double> currentErrorCov(numUnknowns, numUnknowns, 0.0);


               // Set first part of current state vector and covariance matrix
            for( int i=0; i<numVar; i++ )
            {
               currentState(i) = solution(i);

                  // This fills the upper left quadrant of covariance matrix
               for( int j=0; j<numVar; j++ )
               {
                  currentErrorCov(i,j) =  covMatrix(i,j);
               }
            }


               // Fill in the rest of state vector and covariance matrix
               // These are values that depend on satellites being processed
            int c1(numVar);
            for( SatIDSet::const_iterator itSat = satSet.begin();
                 itSat != satSet.end();
                 ++itSat )
            {

                  // Put ambiguities into state vector
               currentState(c1) = KalmanData[*itSat].ambiguity;

                  // Put ambiguities covariance values into covariance matrix
                  // This fills the lower right quadrant of covariance matrix
               int c2(numVar);
               SatIDSet::const_iterator itSat2;
               for( itSat2 = satSet.begin(); itSat2 != satSet.end(); ++itSat2 )
               {

                  currentErrorCov(c1,c2) = KalmanData[*itSat].aCovMap[*itSat2];
                  currentErrorCov(c2,c1) = KalmanData[*itSat].aCovMap[*itSat2];

                  ++c2;
               }

                  // Put variables X ambiguities covariances into
                  // covariance matrix. This fills the lower left and upper
                  // right quadrants of covariance matrix
               int c3(0);
               TypeIDSet::const_iterator itType;
               for( itType  = defaultEqDef.body.begin();
                    itType != defaultEqDef.body.end();
                    ++itType )
               {

                  currentErrorCov(c1,c3) = KalmanData[*itSat].vCovMap[*itType];
                  currentErrorCov(c3,c1) = KalmanData[*itSat].vCovMap[*itType];

                  ++c3;
               }

               ++c1;
            }


               // Reset Kalman filter to current state and covariance matrix
            xhat = currentState;
            P    = currentErrorCov;

         }  // End of 'if(firstTime)'

      }
      catch(SVNumException& s)
      {
            // Rethrow the SVNumException
         GPSTK_RETHROW(s);

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

      return gData;

   }  // End of method 'SolverPPPNL::preCompute()'



      // Compute the solution of the given equations set.
      //
      // @param gData    Data object holding the data.
      //
      // \warning A typical kalman filter will be devided into 
      // two different phase, the prediction and the correction.
      // for some special application, for example, the 'integer'
      // satellite and receiver clock/bias estimation, the ambiguity
      // constraints are generated using the 'predicted' ambiguity 
      // values and its variances. 
      //
   gnssRinex& SolverPPPNL::Compute( gnssRinex& gData )
      throw(InvalidSolver)
   {

         // Call the TimeUpdate() of the kalman filter, which will predict the 
         // state vector and their covariance matrix
      TimeUpdate( phiMatrix, qMatrix );


         // Now, Search the 'independent' ambiguity daum according to their
         // weight, then fix it to nearest integer.
      AmbiguityConstr( gData );


         // Call the MeasUpdate() of the kalman filter, which will update the 
         // state vector and their covariance using new measurements.
      MeasUpdate( measVector, hMatrix, rMatrix );


         // Now, fix the narrowlane ambiguities.
      AmbiguityFixing( gData );


         // Return  
      return gData;

   }  // End of method 'SolverPPPNL::Compute()'


    

      // Predict the state vector and covariance matrix
      //
      // @param gData    Data object holding the data.
      //
   int SolverPPPNL::TimeUpdate( const Matrix<double>& phiMatrix,
                                const Matrix<double>& processNoiseCovariance )
      throw(InvalidSolver)
   {

         // Check whether the phiMatrix is square
      if (!(phiMatrix.isSquare()))
      {
         InvalidSolver e("phiMatrix is not square");
         GPSTK_THROW(e);
      }


      int stateSize(xhat.size());
      if(!(stateSize==numUnknowns))
      {
         InvalidSolver e("TimeUpdate(): Size of a posteriori state estimation vector \
do not match the number of unknowns");
         GPSTK_THROW(e);
      }


      int phiRow = static_cast<int>(phiMatrix.rows());
      if (!(phiRow==numUnknowns))
      {
         InvalidSolver e("Number of unknowns does not match dimension \
of phiMatrix");
         GPSTK_THROW(e);
      }

      if (!(qMatrix.isSquare()))
      {
         InvalidSolver e("qMatrix is not square");
         GPSTK_THROW(e);
      }

      int qRow = static_cast<int>(qMatrix.rows());
      if (!(qRow==numUnknowns))
      {
         InvalidSolver e("Number of unknowns does not match dimension \
of qMatrix");
         GPSTK_THROW(e);
      }

      try
      {
            // Compute the a priori state vector
         xhatminus = phiMatrix*xhat;

         Matrix<double> phiT(transpose(phiMatrix));

            // Compute the a priori estimate error covariance matrix
         Pminus = phiMatrix*P*phiT + processNoiseCovariance;

      }
      catch(...)
      {
         InvalidSolver e("TimeUpdate(): Unable to predict next state.");
         GPSTK_THROW(e);
         return -1;
      }
        
      return 0;

   }  // End of method 'SolverPPPNL::TimeUpdate()'



   gnssRinex& SolverPPPNL::AmbiguityConstr( gnssRinex& gData )
      throw(ProcessingException)
   {
      try
      {

            // Firstly, Get the widelane ambiguity values and flags
            // from 'gData', and then compute the narrowlane ambiguity
            // values and variances for 'satSet', and set the variance
            // as a big 'value' if the widelane ambiguity has not been
            // fixed.

            // Get the number of satellites currently visible
         numCurrentSV = gData.numSats();

            // Widelane ambiguity value and flag vector for current satellites
         Vector<double> currAmbWL(numCurrentSV,0.0);
         Vector<double> currAmbWLFlag(numCurrentSV, 0.0);
          
            // Get widelane ambiguity values and flags for current satellites
         currAmbWL     = gData.getVectorOfTypeID(TypeID::BWL);
         currAmbWLFlag = gData.getVectorOfTypeID(TypeID::BWLFlag);

            // Get the number of satellites to be processed
         int numSV( satSet.size() );

            // Get widelane ambiguity values and flags for 'satSet'
         Vector<double> ambWL(numSV,0.0);
         Vector<double> ambWLFlag(numSV, 0.0);

            // Now, fill the 'ambWL' values for 'satSet' 
            // We must be careful because not all processed satellites
            // are currently visible
         int count1(0);
         for( SatIDSet::const_iterator itSat = currSatSet.begin();
              itSat != currSatSet.end();
              ++itSat )
         {
               // Find in which position of 'satSet' is the current '(*itSat)'
               // Please note that 'currSatSet' is a subset of 'satSet'
            int j(0);
            SatIDSet::const_iterator itSat2( satSet.begin() );
            while( (*itSat2) != (*itSat) )
            {
               ++j;
               ++itSat2;
            }

               // Copy the ambiguity value in the right place
            ambWL(j)  = currAmbWL(count1);

               // Copy the ambiguity flag in the right place
            ambWLFlag(j)  = currAmbWLFlag(count1);

               // Increment
            ++count1;

         }  // End of 'for( itSat = satSet.begin(); ... )'


            // Narrowlane ambiguity value and covariance map
         std::map<SatID, double>  ambMapNL;
         std::map<SatID, std::map<SatID, double> > ambCovMapNL;

            // Lambda for ambNW and ambNL on LC combination
         const double lambNL = 0.106953378 ;
         const double lambWL = 0.377482511 ;

            // Coefficicent 
            // Warning: please note the sign of the ambiguity coefficient
            // the coeff of B3 is -1.0, then ca will be positive.
            // b3 = lambNL*NL + lambWL*Nw;

            // Fill the 'ambMapNL' and 'ambCovMapNL'
         int i(0);
         for( SatIDSet::const_iterator itSat = satSet.begin();
              itSat != satSet.end();
              ++itSat )
         {
               // Get the combined ambiguity on LC combination
            double blc = xhatminus( i + numVar );

               // Get the variance for 'ambLC'
            double blcCov = Pminus( i + numVar, i + numVar );

               // Get the widelane ambiguity value
            double bwl = ambWL(i);

               // If the widelane ambiguity has been fixed
               // Warning: only store the satellite with widelane ambiguity fixed.
            if( ambWLFlag(i) )
            {
                  // Compute the narrowlane ambiguity by using the formula:
               ambMapNL[ (*itSat) ] = (blc - lambWL*bwl)/lambNL ;

                  // Compute the blc variance by using the formula: 
                  // Cov(Y) = F*Cov(x)*F^(T) 
               ambCovMapNL[ (*itSat) ][ (*itSat) ] = blcCov/(lambNL*lambNL) ;

               cout << " sat:" << (*itSat) 
                    << " blc:" << blc
                    << " blcCov:" << blcCov
                    << " ambL1Map:"  << ambMapNL[ (*itSat) ] 
                    << " covAmbL1Map:" << ambCovMapNL[ (*itSat) ][ (*itSat) ] << endl;

            }

               // Increment
            i++;
         }

            // Clear the map
         ambFixedMapNL.clear();

            // Set the ambiguity value and covariance map
         ambiguityDatum.Reset( ambMapNL, ambCovMapNL);

            // Now, Let's fix one satellite's ambiguity as datum
         ambiguityDatum.Prepare( gData );

            // Ambiguity datum SatID
         ambFixedMapNL = ambiguityDatum.getAmbFixedMap();

            // Number of ambiguities that can be fixed
         int numFix( ambFixedMapNL.size() );
         
         cout << "numFix" << numFix << endl;

            // Throw exception
         if( numFix != 1 )
         {
               // Throw an exception if something unexpected happens
            ProcessingException e("The ambiguity constraint equation number is 0.");

               // Throw the exception
            GPSTK_THROW(e);

         }  // End of 'If(...)'

            // Map iterator
         std::map<SatID, double>::iterator itmap = ambFixedMapNL.begin();

            // Get the reference SatID
         SatID refSat = ( (*itmap).first );

         cout << "refSat:" << refSat  << endl;
         cout << "fixedValue" << (*itmap).second << endl;

         /////////////////////////////////////////////////////////////////
         //
         // Now, Let's compute the single difference values for 'diffTypes'
         //
         /////////////////////////////////////////////////////////////////

            // Single difference satellie number
         int numSDSV( numCurrentSV - 1 );

            // Type number in 'diffTypes'
         int numType(diffTypes.size());

            // Resize the diffData
         diffData.resize(numSDSV, numType, 0.0);

            // SatIDSet to be rejected
         SatIDSet satRejectedSet;

            // Loop through all the satellites in station data set
         int row(0);
         for (satTypeValueMap::iterator it = gData.body.begin(); 
              it != gData.body.end(); 
              ++it)
         {
               // 'refSat' is the reference one
            if( (*it).first != refSat )
            {
                  // Compute the difference for all types in 'diffTypes' set
               int col(0);
               for(TypeIDSet::const_iterator itType = diffTypes.begin(); 
                   itType != diffTypes.end(); 
                   ++itType)
               {
                  double value1(0.0);
                  double value2(0.0);

                  cout << "itType:" << (*itType) << endl;

                  try
                  {
                        // Let's try to compute the difference
                     value1 = gData.body((*it).first)(*itType);
                     value2 = gData.body(refSat)(*itType);

                     cout << "sat" << (*it).first << "meas" << value1 << endl;
                     cout << "ref" << refSat << "meas" << value2 << endl;

                     if( (*itType) == TypeID::weight )
                     {
                        diffData(row,col) = 1.0/( 1.0/value1 + 1.0/value2 );
                     }
                     else
                     {
                        diffData(row,col) = value1 - value2;
                     }

                  }
                  catch(...)
                  {
                        // Remove this satellite
                     satRejectedSet.insert( (*it).first );
                     continue;
                  }

                     // Type number increment
                  ++col;

               }  // End of 'for(itType = diffTypes.begin(); ...'

                  // Satellite number increment
               ++row;

            }  // End of 'if( (*it).first != refSat )'

         }  // End of 'for (it = gData.begin(); it != gData.end(); ++it)'


         /////////////////////////////////////////////////////////////////
         //
         // Now, Define new single difference observation equation, and
         // fill the hMatrix/rMatrix/measVector according with the single
         // differenced values.
         //
         /////////////////////////////////////////////////////////////////
         
         cout << "diffData" << endl;
         cout <<  diffData << endl;

            // Number of measurements is twice the number of visible satellites minus
            // 1 reference satellites.
         numMeas = 2 * ( numSDSV );

            // Measurement vector
         measVector.resize(numMeas, 0.0);

            // Fill the 'prefitL1' measurement
         for( int i=0; i<numSDSV; i++ )
         {
            measVector(           i ) = diffData(i,1); // prefitC
            measVector( numSDSV + i ) = diffData(i,2); // prefitL
         }

         cout << "measVector" << endl;
         cout <<  measVector  << endl;

            //
            // Now, fill the geometry matrix
            //

            // Generate the corresponding geometry/design matrix
         hMatrix.resize(numMeas, numUnknowns, 0.0);

            // Let's fill the coefficients related to the 'core' variables,
            // i.e. tropo, coordinates (NOT include the receiver clock)
         for( int i=0; i<numSDSV; i++ )
         {
            hMatrix( i          , 0 ) = diffData(i, 0);
            hMatrix( i + numSDSV, 0 ) = diffData(i, 0);

            hMatrix( i          , 1 ) = diffData(i, 3);
            hMatrix( i + numSDSV, 1 ) = diffData(i, 3);

            hMatrix( i          , 2 ) = diffData(i, 4);
            hMatrix( i + numSDSV, 2 ) = diffData(i, 4);

            hMatrix( i          , 3 ) = diffData(i, 5);
            hMatrix( i + numSDSV, 3 ) = diffData(i, 5);

         }  // End of 'for( int i=0; i<numCurrentSV; i++ )'

            // Now, fill the coefficients related to phase biases

            // Now, find the position of refSat in 'satSet'
         int jref(0);
         SatIDSet::const_iterator itSat2( satSet.begin() );
         while( (*itSat2) != refSat )
         {
            ++jref;
            ++itSat2;
         }

            // We must be careful because not all processed satellites
            // are currently visible
         int count2(0);
         for( SatIDSet::const_iterator itSat = currSatSet.begin();
              itSat != currSatSet.end();
              ++itSat )
         {
               // Only set the "active" satellite
            if( (*itSat) != refSat )
            {
                  // Find in which position of 'satSet' is the current '(*itSat)'
                  // Please note that 'currSatSet' is a subset of 'satSet'
               int j(0);
               SatIDSet::const_iterator itSat2( satSet.begin() );
               while( (*itSat2) != (*itSat) )
               {
                  ++j;
                  ++itSat2;
               }

                  // Put coefficient in the right place
               hMatrix( count2 + numSDSV, j    + numVar ) = -1.0;

                  // Put coefficient of the 'refSat'  
               hMatrix( count2 + numSDSV, jref + numVar ) = +1.0;

                  // Increment
               ++count2;
            }

         }  // End of 'for( itSat = satSet.begin(); ... )'

         cout << "hMatrix" << endl;
         cout <<  hMatrix  << endl;

            /**
             * Now, get the weight matrix
             */

            // Weights matrix
         rMatrix.resize(numMeas, numMeas, 0.0);

            // Generate the appropriate weights matrix
            // Try to extract weights from GDS
         satTypeValueMap dummy(gData.body.extractTypeID(TypeID::weight));

            // Check if weights match
            // here the dummy size is only used to check whether we have
            // weight values in 'gData'
         if ( dummy.numSats() == numCurrentSV )
         {

            for( int i=0; i<numSDSV; i++ )
            {
               rMatrix( i          , i          ) 
                  = diffData(i, numType-1 );
               rMatrix( i + numSDSV, i + numSDSV) 
                  = diffData(i, numType-1) * weightFactor;
            }  

         }  // End of 'if ( dummy.numSats() == numCurrentSV )'

         cout << "rMatrix" << endl;
         cout <<  rMatrix  << endl;


         /////////////////////////////////////////////////////////////////
         //
         // Now, Let's fill the measVector/hMatrix/rMatrix for the
         // datum ambiguity
         //
         /////////////////////////////////////////////////////////////////

            // Prefit/geometry/weight matrix  
         Vector<double> measVectorFix(1,0.0);
         Matrix<double> hMatrixFix(1, numUnknowns,0.0);
         Matrix<double> rMatrixFix(1, numFix,0.0);

            // The narrowlane ambiguity
         double bnl = ambFixedMapNL[ refSat ];

            // The widelane ambiguity
         double bwl = ambWL(jref);

            // Compute the fixed LC ambiguity 
         double blc = lambNL* bnl + lambWL * bwl; 

         cout << "bnl" << bnl << "bwl" << bwl << endl;
         cout << "blc" << blc << endl;

            // Prefit equals the fixed ambiguity value 
         measVectorFix( 0 ) = blc;

            // Coefficient of ambiguity is set to 1.0
         hMatrixFix( 0, numVar + jref) = 1.0;

            // The weight is set to a large value
         rMatrixFix( 0, 0) = 1.0E+8;

            // Now, Let's combine all the equations together

            // The observation equation number is enlarged
         int numEqu( numMeas + 1);

            // New observation prefit/geometry/weight matrix
         Vector<double> tempPrefit(numEqu, 0.0);
         Matrix<double> tempGeometry(numEqu, numUnknowns, 0.0);
         Matrix<double> tempWeight(numEqu, numEqu, 0.0);

            // Now, Let's store the tempPrefit1/tempGeometry1/tempWeight1
         for(int i=0; i<numMeas; i++)
         {
               // Prefit
            tempPrefit(i) = measVector(i); 

               // Geometry
            for(int j=0; j<numUnknowns; j++) 
            { 
               tempGeometry(i,j) = hMatrix(i,j); 
            }

               // Weight
            tempWeight(i,i) = rMatrix(i,i); 

         }  

            // Now, Let's store the measVectorFix/hMatrixFix/rMatrixFix
            
            // Prefit
         tempPrefit(numMeas) = measVectorFix(0); 

            // Geometry
         for(int j=0; j<numUnknowns; j++)
         {
            tempGeometry(numMeas,j) = hMatrixFix(0,j); 
         }  

            // Weight
         tempWeight(numMeas, numMeas)  = rMatrixFix(0,0); 

            // Resize the measVector/hMatrix/rMatrix
         measVector.resize(numEqu,  0.0);
         hMatrix.resize(numEqu, numUnknowns, 0.0);
         rMatrix.resize(numEqu, numEqu, 0.0);

            // New Measurement vector update
         measVector = tempPrefit ;
         hMatrix = tempGeometry ;
         rMatrix = tempWeight ;

         cout << "measVector" << endl;
         cout <<  measVector << endl;

         cout << "hMatrix" << endl;
         cout <<  hMatrix<< endl;

         cout << "rMatrix" << endl;
         cout <<  rMatrix<< endl;

            // Return 
         return gData;

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPNL::AmbiguityConstr()'



      // Correct the state vector and covariance matrix
      //
      // @param gData    Data object holding the data.
      //
   int SolverPPPNL::MeasUpdate( const Vector<double>& prefitResiduals,
                                const Matrix<double>& designMatrix,
                                const Matrix<double>& weightMatrix )
      throw(InvalidSolver)
   {

         // By default, results are invalid
      valid = false;

      if (!(weightMatrix.isSquare()))
      {
         InvalidSolver e("MeasUpdate(): Weight matrix is not square");
         GPSTK_THROW(e);
      }


      int wRow = static_cast<int>(weightMatrix.rows());
      int pRow = static_cast<int>(prefitResiduals.size());
      if (!(wRow==pRow))
      {
         InvalidSolver e("MeasUpdate(): prefitResiduals size does not match dimension of \
weightMatrix");
         GPSTK_THROW(e);
      }


      int gRow = static_cast<int>(designMatrix.rows());
      if (!(gRow==pRow))
      {
         InvalidSolver e("MeasUpdate(): prefitResiduals size does not match \
dimension of designMatrix");
         GPSTK_THROW(e);
      }


      int gCol = static_cast<int>(designMatrix.cols());
      int aprioriStateRow = static_cast<int>(xhatminus.size());
      if (!(gCol==aprioriStateRow))
      {
         InvalidSolver e("MeasUpdate(): designMatrix size and a priori state \
estimation vector do not match.");
         GPSTK_THROW(e);
      }


      int pMCol = static_cast<int>(Pminus.cols());
      if ( pMCol != aprioriStateRow )
      {
         InvalidSolver e("MeasUpdate(): Sizes of a priori error covariance \
matrix and a priori state estimation vector do not match.");
         GPSTK_THROW(e);
      }


         // After checking sizes, let's do the real correction work
      Matrix<double> invPMinus;
      Matrix<double> designMatrixT( transpose(designMatrix) );

      try
      {
//       cout << "Pminus" << endl;
//       cout <<  Pminus  << endl;

         invPMinus = inverseChol(Pminus);

      }
      catch(...)
      {
         InvalidSolver e("MeasUpdate(): Unable to compute invPMinus matrix.");
         GPSTK_THROW(e);
         return -1;
      }

      try
      {

         Matrix<double> invTemp( designMatrixT * weightMatrix * designMatrix +
                                 invPMinus );

            // Compute the a posteriori error covariance matrix
         P = inverseChol( invTemp );

      }
      catch(...)
      {
         InvalidSolver e("MeasUpdate(): Unable to compute P matrix.");
         GPSTK_THROW(e);
         return -1;
      }

      try
      {

            // Compute the a posteriori state estimation
         xhat = P * ( (designMatrixT * weightMatrix * prefitResiduals) + 
                      (invPMinus * xhatminus) );

      }
      catch(Exception e)
      {
         InvalidSolver eis("MeasUpdate(): Unable to compute xhat.");
         GPSTK_THROW(eis);
         return -1;
      }

      solution = xhat;
      covMatrix = P;

         // Compute the postfit residuals Vector
      postfitResiduals = prefitResiduals - (designMatrix * solution);

         // If everything is fine so far, then the results should be valid
      valid = true;

      return 0;

   }  // End of method 'SolverPPPNL::MeasUpdate()'



      // Now, fix all the ambiguities to integers 
   gnssRinex& SolverPPPNL::AmbiguityFixing( gnssRinex& gData )
      throw(ProcessingException)
   {

      try
      {

            // Firstly, Get the widelane ambiguity values and flags
            // from 'gData', and then compute the narrowlane ambiguity
            // values and their covariances for 'satSet'.
            
            // Lambda for ambNW and ambNL on LC combination
         const double lambNL = 0.106953378 ;
         const double lambWL = 0.377482511 ;

            // Get the number of satellites currently visible
         numCurrentSV = gData.numSats();

            // Widelane ambiguity value and flag vector for current satellites
         Vector<double> currAmbWL(numCurrentSV,0.0);
         Vector<double> currAmbWLFlag(numCurrentSV, 0);
          
            // Get widelane ambiguity values and flags for current satellites
         currAmbWL     = gData.getVectorOfTypeID(TypeID::BWL);
         currAmbWLFlag = gData.getVectorOfTypeID(TypeID::BWLFlag);

            // Get the number of satellites to be processed
         int numSV( satSet.size() );

            // Get widelane ambiguity values and flags for 'satSet'
         Vector<double> ambWL(numUnknowns,0.0);
         Vector<double> ambWLFlag(numUnknowns, 0);

            // Reset
         numAmbWLFixed = 0;

            // Now, fill the 'ambWL' values for 'satSet' 
            // We must be careful because not all processed satellites
            // are currently visible
         int count1(0);
         for( SatIDSet::const_iterator itSat = currSatSet.begin();
              itSat != currSatSet.end();
              ++itSat )
         {
               // Find in which position of 'satSet' is the current '(*itSat)'
               // Please note that 'currSatSet' is a subset of 'satSet'
            int j(numVar);
            SatIDSet::const_iterator itSat2( satSet.begin() );
            while( (*itSat2) != (*itSat) )
            {
               ++j;
               ++itSat2;
            }

               // Copy the ambiguity value in the right place
            ambWL(j)  = currAmbWL(count1);

               // Copy the ambiguity flag in the right place
            ambWLFlag(j)  = currAmbWLFlag(count1);

               // The fixed widelane ambiguity number
            if(ambWLFlag(j))
            {
               numAmbWLFixed ++;
            }

               // Increment
            ++count1;

         }  // End of 'for( itSat = satSet.begin(); ... )'


//       cout << "solution" << endl;
//       cout <<  solution  << endl;

//       cout << "covMatrix" << endl;
//       cout <<  covMatrix  << endl;

            // Now, define the temporary solution and covMatrix
         newState = solution ;
         newCovariance = covMatrix ;

            // Temp Variables
         double sigma, blc, bwl, bnl, blcVar, bnlVar, bnlSig;
         double decision, ambNLFixed, ambWLFixed, ambLCFixed;

            // Cutting decision for ambiguity fixing 
         double cutDec(1000.0);

            // Vector to indicate the state of the unknowns: 
            // 1 means free and 0 means fixed.
         Vector<double> ambNL(numUnknowns, 0.0);
         Vector<double> ambNLFlag(numUnknowns, 0.0);

            // Ambiguity fixing method
         ARRound ambRes(1000,0.2,0.2);

            // Still have ambiguity to be fixed?
         bool done(false);

            // Loop to fix a ambiguity
         while( !done )
         {
               // Indicator variable
            int index(-1);
            double maxDec(-100.0);

               // Only fix the ambiguity unks 
            for( int i=numVar; i<numUnknowns; i++)
            {
                  // If still free 
               if( (ambWLFlag(i) == 1.0) && 
                   (ambNLFlag(i) == 0.0) )
               {
                     // LC ambiguity
                  blc = newState(i);

                     // LC ambiguity variance
                  blcVar = newCovariance(i,i);

                     // Widelane ambiguity
                  bwl = ambWL(i) ;

                     // Narrowlane ambiguity
                  bnl = (blc - lambWL*bwl)/lambNL;

                     // Narrowlane ambiguity variance
                  bnlVar = blcVar/(lambNL*lambNL) ;

                  cout << "blc amb:" << blc 
                       << "blc variance:" << blcVar
                       << "bnl amb:" << bnl 
                       << "bnl variance:" << bnlVar
                       << endl;

                     // Sigma of narrowlane ambiguity
                  bnlSig = std::sqrt( bnlVar );

                     // Ambiguity fixing decision
                  decision = ambRes.getDecision(bnl, bnlSig);

                     // Look for the largest fixing decision
                  if( decision > maxDec )
                  {
                     index = i;
                     maxDec = decision;
                  }

               }  // End of 'if( ambNLFlag(i) == 0.0 ) '

            }   // End of 'for(int i=numVar; ... )'

               // If found 
            if(index != -1)
            {
                  // If can be fixed
               if( maxDec > cutDec )
               {
                     // Ambiguity value
                  blc = newState(index);

                     // Variance 
                  blcVar = newCovariance(index,index);

                     // Widelane ambiguity
                  ambWLFixed = ambWL(index) ;

                     // Narrowlane ambiguity
                  bnl  = (blc - lambWL*ambWLFixed)/lambNL;

                     // Narrowlane ambiguity variance
                  bnlVar = blcVar/(lambNL*lambNL);

                  cout << "blc amb:" << blc 
                       << "blc variance:" << blcVar
                       << "bnl amb:" << bnl 
                       << "bnl variance:" << bnlVar
                       << endl;

                     // Get the fixed ambiguity value
                  ambNLFixed = ambRes.resolve(bnl, bnlVar);

                     // Compute the fixed LC ambiguity 
                  ambLCFixed = lambNL* ambNLFixed + lambWL * ambWLFixed;

                     // Update the solution and covarinace  
                  AmbiguityUpdate(newState, newCovariance, ambNLFlag, index, ambLCFixed);

                     // Store the fixed narrowlane ambiguity into 'ambNL'
                  ambNL(index) = ambNLFixed;

                     // Not free at all
                  ambNLFlag(index) = 1.0;

                     // Store the fixed ambiguity value into 'newState'
                  newState(index) = ambLCFixed;

               }
               else
               {
                    // If ambiguity can't be fixed
                  done = true;
               } 

            }
            else
            {
                 // if no ambiguity is found
               done = true;
            }
                
         }  // End of 'while(done)'


            // New vector to store the flags
         Vector<double> currBL1(numCurrentSV,0.0);
         Vector<double> currBLC(numCurrentSV,0.0);
         Vector<double> currBL1Flag(numCurrentSV,0.0);


            // Number of fixed narrowlane ambiguities
         numCurrentFixedSV = 0;

            // Now, only take out current ambiguity and their state 
         int count2(0);
         for( SatIDSet::const_iterator itSat = currSatSet.begin();
              itSat != currSatSet.end();
              ++itSat )
         {
            int jcol(numVar);
            SatIDSet::const_iterator itSat2( satSet.begin() );
            while( (*itSat2) != (*itSat) )
            {
               ++jcol;
               ++itSat2;
            }

               // The ambiguity value
            currBL1(count2) = ambNL( jcol );

               // The ambiguity value
            currBLC(count2) = newState( jcol );

               // The ambiguity fixed flag
            currBL1Flag(count2) = ambNLFlag( jcol );

               // If the widelane satellite is fixed
            if( currBL1Flag(count2) )
            {
               numCurrentFixedSV++;
            }

               // Index increment
            ++count2;

         }

//       cout << " NL Fixing rate: " 
//            << " epoch: " << gData.header.epoch  
//            << " numCurrentSV: " <<  numCurrentSV 
//            << " numCurrentFixedSV: " << numCurrentFixedSV 
//            << endl;

         cout << "BNL" << endl;
         cout <<  currBL1  << endl;

//       cout << "BLC" << endl;
//       cout <<  currBLC  << endl;

         cout << "BL1Flag" << endl;
         cout <<  currBL1Flag  << endl;

            // Now we have to add the BL1/BLC to the data structure
            // warning: the unit for BL1 is "cycle" and the unit 
            //          for BLC is "meter"
         gData.insertTypeIDVector(TypeID::BL1,     currBL1);
         gData.insertTypeIDVector(TypeID::BLC,     currBLC);
         gData.insertTypeIDVector(TypeID::BL1Flag, currBL1Flag);


            /**
             * Insert the zenith wetdelay into 'gData'
             */
            
            // Vector to store the receiver clock 
         Vector<double> zwd(numCurrentSV,0.0);

            // Set the receiver clock for each satelite, which 
            // will be convienent for correction computing
         count2 = 0;
         for( SatIDSet::const_iterator itSat = currSatSet.begin();
              itSat != currSatSet.end();
              ++itSat )
         {
               // Set the receiver clock 
            zwd(count2) = newState(0);

               // Index increment
            ++count2;
         }

            // Insert the receiver clock into each current visible satellite
         gData.insertTypeIDVector(TypeID::wetTropo, zwd);
         
            // Warning:
            // If you want to store the state/covariance to solution/covMatrix,
            // you MUST set the fixed ambiguities' variance and covariance as
            // very small values, e.g. 1.0e-10.
//       solution = newState;
//       covMatrix = newCovariance;

            // Return 
         return gData;

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPNL::AmbiguityFixing()'



      /** Update the free unknonws' solution and covariance after
       *  fixing the ambiguities
       */
   int SolverPPPNL::AmbiguityUpdate( Vector<double>& state,
                                     Matrix<double>& covariance,
                                     Vector<double>& fixedFlag,
                                     int& index,
                                     double& fixedValue )
      throw(ProcessingException)
   {

      try
      {
            // Variance epsilon to avoid numerical exception
         const double eps(1.0e-9);

            // Covariance related to the fixed ambiguity
         Vector<double> Qba(numUnknowns, 0.0);

            // Get the covariance
         for( int i=0; i<numUnknowns; i++)
         {
            Qba(i) = covariance(i,index);
         }

            // Qii
         double Qaa;
         Qaa = Qba(index) + eps;
         Qaa = 1.0/Qaa;

            // Free value
         double freeValue = state(index);

            // Solution udpate
         for(int i=0; i<numUnknowns; i++)
         {
            if( fixedFlag(i) == 0.0 )
            {
               state(i) = state(i) + Qba(i)*Qaa*(fixedValue - freeValue); 
            }
         }

            // Covariance update
         for(int i=0; i<numUnknowns; i++)
         {
            if( fixedFlag(i) == 0.0 )
            {
               for(int j=0; j<numUnknowns; j++)
               {
                  if( fixedFlag(j) == 0.0 )
                  {
                     covariance(i,j) = covariance(i,j) - Qba(i)*Qaa*Qba(j);
                  }
               }
            }
         }

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

   }  // End of method 'SolverPPPNL::AmbiguityUpdate()'


      /* Code to be executed after 'Compute()' method.
       *
       * @param gData    Data object holding the data.
       */
   gnssRinex& SolverPPPNL::postCompute( gnssRinex& gData )
      throw(ProcessingException)
   {

      try
      {
         cout << "postCompute" << endl;

            // Store those values of current state and covariance matrix
            // that depend on satellites currently in view
         int c1(numVar);
         for( SatIDSet::const_iterator itSat = satSet.begin();
              itSat != satSet.end();
              ++itSat )
         {

               // Store ambiguities
            KalmanData[*itSat].ambiguity = solution(c1);

               // Store ambiguities covariance values
            int c2(numVar);
            SatIDSet::const_iterator itSat2;
            for( itSat2 = satSet.begin(); itSat2 != satSet.end(); ++itSat2 )
            {

               KalmanData[*itSat].aCovMap[*itSat2] = covMatrix(c1,c2);

               ++c2;
            }

               // Store variables X ambiguities covariances
            int c3(0);
            TypeIDSet::const_iterator itType;
            for( itType  = defaultEqDef.body.begin();
                 itType != defaultEqDef.body.end();
                 ++itType )
            {

               KalmanData[*itSat].vCovMap[*itType] = covMatrix(c1,c3);

               ++c3;
            }

            ++c1;

         }  // End of 'for( itSat = satSet.begin(); ...'


            // Get the number of satellites currently visible
         numCurrentSV = gData.numSats();


            // Now we have to add the new values to the data structure
         Vector<double> postfitCode(numCurrentSV,0.0);
         Vector<double> postfitPhase(numCurrentSV,0.0);
         for( int i=0; i<numCurrentSV; i++ )
         {
            postfitCode(i)  = postfitResiduals( i                );
            postfitPhase(i) = postfitResiduals( i + numCurrentSV );
         }

         gData.insertTypeIDVector(TypeID::postfitC, postfitCode);
         gData.insertTypeIDVector(TypeID::postfitL, postfitPhase);


            // Update set of satellites to be used in next epoch
         satSet = currSatSet;

         cout << "end of postCompute" << endl;

      }
      catch(Exception& u)
      {
            // Throw an exception if something unexpected happens
         ProcessingException e( getClassName() + ":"
                                + StringUtils::asString( getIndex() ) + ":"
                                + u.what() );

         GPSTK_THROW(e);

      }

      return gData;

   }  // End of method 'SolverPPPNL::postCompute()'



      /* Sets if a NEU system will be used.
       *
       * @param useNEU  Boolean value indicating if a NEU system will
       *                be used
       *
       */
   SolverPPPNL& SolverPPPNL::setNEU( bool useNEU )
   {

      ///////////////////////////// /////////////////////////////
      //
      //                        NOTES
      // Because the receiver clocks of PC and LC combination are
      // different, the single-difference of PC and LC combinations
      // are formed to eliminate the receiver clock parameters. 
      // Then, the unknown parameters are the receiver coordinates
      // and receiver ambiguities.
      //
      ///////////////////////////// /////////////////////////////
      
         // First, let's define a set with the typical code-based unknowns
      TypeIDSet tempSet;

         // Watch out here: 'tempSet' is a 'std::set', and all sets order their
         // elements. According to 'TypeID' class, this is the proper order:
      tempSet.insert(TypeID::wetMap);  // BEWARE: The first is wetMap!!!

      if (useNEU)
      {
         tempSet.insert(TypeID::dLat); // #2
         tempSet.insert(TypeID::dLon); // #3
         tempSet.insert(TypeID::dH);   // #4
      }
      else
      {
         tempSet.insert(TypeID::dx);   // #2
         tempSet.insert(TypeID::dy);   // #3
         tempSet.insert(TypeID::dz);   // #4
      }


         // Now, we build the basic equation definition
      defaultEqDef.header = TypeID::prefitC;
      defaultEqDef.body = tempSet;

         // Watch out the order of the 'diffType' in 'TypeID'
         // According to the definition of 'TypeID'.
         // The proper order is as the following:
         // wetMap
         // prefitC
         // prefitL
         // dx
         // dy
         // dz
         // weight

         // Firstly, clear the 'diffTypes'
      diffTypes.clear();
       
         // The wetMap
      diffTypes.insert(TypeID::wetMap);  

         // Define the types to be differenced
      diffTypes.insert(TypeID::prefitC);
      diffTypes.insert(TypeID::prefitL);


         // The 3 coordinate unknowns
      if (useNEU)
      {
         diffTypes.insert(TypeID::dLat); // #1
         diffTypes.insert(TypeID::dLon); // #2
         diffTypes.insert(TypeID::dH);   // #3
      }
      else
      {
         diffTypes.insert(TypeID::dx);   // #1
         diffTypes.insert(TypeID::dy);   // #2
         diffTypes.insert(TypeID::dz);   // #3
      }

         // The weight 
      diffTypes.insert(TypeID::weight);

      return (*this);

   }  // End of method 'SolverPPPNL::setNEU()'



      /* Set a single coordinates stochastic model to ALL coordinates.
       *
       * @param pModel      Pointer to StochasticModel associated with
       *                    coordinates.
       *
       * @warning Do NOT use this method to set the SAME state-aware
       * stochastic model (like RandomWalkModel, for instance) to ALL
       * coordinates, because the results will certainly be erroneous. Use
       * this method only with non-state-aware stochastic models like
       * 'StochasticModel' (constant coordinates) or 'WhiteNoiseModel'.
       */
   SolverPPPNL& SolverPPPNL::setCoordinatesModel( StochasticModel* pModel )
   {

         // All coordinates will have the same model
      pCoordXStoModel = pModel;
      pCoordYStoModel = pModel;
      pCoordZStoModel = pModel;

      return (*this);

   }  // End of method 'SolverPPPNL::setCoordinatesModel()'


   
       /** Set the positioning mode, kinematic or static.
        */
   SolverPPPNL& SolverPPPNL::setKinematic( bool kinematicMode,
                                       double sigmaX,
                                       double sigmaY,
                                       double sigmaZ )
   {
      if(kinematicMode)
      {
         whitenoiseModelX.setSigma(sigmaX);
         whitenoiseModelY.setSigma(sigmaY);
         whitenoiseModelZ.setSigma(sigmaZ);

         setXCoordinatesModel(&whitenoiseModelX);
         setYCoordinatesModel(&whitenoiseModelY);
         setZCoordinatesModel(&whitenoiseModelZ);
      }
      else
      {
         setCoordinatesModel(&constantModel);
      }

      return (*this);

   }  // End of method 'SolverPPPNL::setKinematic()'



      /* Returns the solution associated to a given TypeID.
       *
       * @param type    TypeID of the solution we are looking for.
       */
   double SolverPPPNL::getSolution(const TypeID& type) const
      throw(InvalidRequest)
   {

         // Define iterator
      TypeIDSet::const_iterator it;

         // Check if the provided type exists in the solution. If not,
         // an InvalidSolver exception will be issued.
      it = defaultEqDef.body.find(type);
      if( it == defaultEqDef.body.end() )
      {
         InvalidRequest e("Type not found in solution vector.");
         GPSTK_THROW(e);
      }


         // Define counter
      int counter(0);

         // Define a new iterator and count where the given type is
      TypeIDSet::const_iterator it2;
      for (it2 = defaultEqDef.body.begin(); it2!= it; it2++)
      {
         ++counter;
      }

      return newState(counter);
//    return solution(counter);

   }  // End of method 'SolverPPPNL::getSolution()'



      /* Returns the variance associated to a given TypeID.
       *
       * @param type    TypeID of the variance we are looking for.
       */
   double SolverPPPNL::getVariance(const TypeID& type) const
      throw(InvalidRequest)
   {

         // Define iterator
      TypeIDSet::const_iterator it;


         // Check if the provided type exists in the covariance matrix. If not,
         // an InvalidSolver exception will be issued.
      it = defaultEqDef.body.find(type);
      if( it == defaultEqDef.body.end() )
      {
         InvalidRequest e("Type not found in covariance matrix.");
         GPSTK_THROW(e);
      }


         // Define counter
      int counter(0);

         // Define a new iterator and count where the given type is
      TypeIDSet::const_iterator it2;
      for (it2 = defaultEqDef.body.begin(); it2!= it; it2++)
      {
         ++counter;
      }

      return newCovariance(counter,counter);
//    return covMatrix(counter,counter);

   }  // End of method 'SolverPPPNL::getVariance()'


      /** Return the CURRENT number of satellite.
       */
   int SolverPPPNL::getCurrentSatNumber() const
      throw(InvalidRequest)
   {
         // Return current fixed satellite number
      return numCurrentSV;
   }


      /** Return the CURRENT number of satellite.
       */
   int SolverPPPNL::getCurrentFixedSatNumber() const
      throw(InvalidRequest)
   {
         // Return current fixed satellite number
      return numCurrentFixedSV;
   }

      /** Return the CURRENT number of satellite.
       */
   int SolverPPPNL::getAmbWLFixedNumber() const
      throw(InvalidRequest)
   {
         // Return current fixed satellite number
      return numAmbWLFixed;
   }




}  // End of namespace gpstk
